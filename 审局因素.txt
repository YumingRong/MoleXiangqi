审局函数的打分因素：
1. 静态子力。
	未过河兵为10分。不分得太细。
2. 动态子力。棋盘上的棋子越多，马的分数越低，炮的分数越高。兵的价值取决于对方车马炮的数量。
	马的最大攻击数为8，根据概率，每个棋子可减少其0.09点攻击。
	炮，每个棋子可增加其0.24点攻击。
	炮是兵种中的一个另类，其机动性和攻击力并不相同。它的机动性与车相似，但攻击力稍逊。
	车的攻击力按14计算，马约等于6.9，兵等于1，过河兵等于3，
3. 棋子位置数组。兵、马、相、仕、将等短程兵种才有。
4. 马和象的机动性。绊马腿和塞象眼。
5. 车炮与对方的将帅同行或同列有加分。
6. 子力配置。进攻兵种齐全有加成。缺相怕炮，缺仕怕双车。
7. 特殊棋形。比如当头炮，中路仕相丧失机动性。

可以考虑的费时的计算：
1. 先检查绝对牵制。被绝对牵制的棋子只有单向机动性（或简化完全不考虑其机动性）
2. generate attack map。
3. 一个棋子控制（空白格）、攻击（对方）和保护（己方棋子）给不同的分数，暂定2,5,3。
4. 重复保护不加分。攻击无根子加分。
5. Banned grid里没有机动性
6. Discovered attack 加分

审局函数只有在静态局面时才有较准确的分数，激烈的对攻只有通过搜索推演至静态局面来评估。
因此审局函数不必对将军、得子等进行评估，只要求达到统计意义上的准确即可。
审局函数用到的知识越少越好，这样才容易优化。
可以用五羊杯的对局来测试，正常情况下，双方分数应呈锯齿状交替上升，总体应该稳定渐变。


评价一个棋子的价值，有三个因子：
1. 攻击力。一个棋子可以同时进攻多少个格子。
2. 机动性。一个棋子可以移动的速度和到达的格子数。
3. 活动范围。将士不出九宫，兵不能后退等。国际象棋的象只能在一种颜色内活动。


下一步测试双车胁仕2和钓鱼马2。

SEE Pseudo code:

void PreSEE()
{
	Generate List<int sqFrom, int sqPinned> AbsolutePins;
}

List<MOVE> GenerateMoves(side = sdPlayer)
{
	Generate List<int sqFrom, int sqPin, int sqTo> RelativePins; //for rook, cannon, knight, bishop
	Generate List<int sqFrom, int sqTo>[2] Captures; //for all except rook and cannon
	Generate List<int sqFrom, int sqTo>[2] Quiets; //for all pieces except cannon
	Generate List<int sqFrom, int sqTo> CannonMoves;  
	List<MOVE> movelist= Captures[side] + Quiets[side] + CannonMoves; 
	Removes those suicide;
	return movelist;
}

int[] ModeMoves()
{
	foreach (MOVE mv in MoveList)
	{
		List<MOVE> attackers = Captures[me] where cap.To == sqDst;
		List<MOVE> defenders = Capptures[opp] where cap.To == sqDst;
		score[i] = SEE(mv.sqDst, attackers, defenders);
	}
}


int SEE(int sqDst, List<MOVE> attackers, List<MOVE> defenders)
{
	MOVE mv = Lowest piece Value in attackers;
	if (mv.sqSrc is in RelativePins.sqPin || mv.sqSrc is in AbsolutePin.sqFrom)
		return UNCERTAIN;
	if (cap.pcFrom == KING)
		if (defenders.Count == 0)
		{
			if (KingsFace2Face)
				return vlDst;
		}
	else
		return 0;
	
	int vlDst = PieceValue[mv.pcDst];
	if (defenders.Count == 0)
		return vlDst;
	MovePiece(mv);
	attackers.Remove(mv);
	List<int sqFrom> Slides = (Rook & Cannon defend where defend.sqDst == sqDst);
	defenders.Append(Slides);

	score = SEE (cap);
	UndoMovePiece(mv);
	return max(0, vlDst - score);
}