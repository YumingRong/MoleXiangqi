DELTA_INC_LINE 返回(from, to)之间的方向(或当不在一直线上时无方向)


void search_full_init(list_t * list, board_t * board) 
1. 读取各种搜素设置及参数 option_get_int(string),option_get_bool(string)

2. list_note(list_t * list)
2.1 void list_note(list_t * list) 给list中的每个MOVE按 -move_order 打分
2.1.1 int move_order(int move) 返回move的from, to 和第13、14位
2.2 void list_sort(list_t * list) 根据value，给list中的move从大到小冒泡排序

3 bool trans_retrieve(trans_t * trans, uint64 key, int * move, int * min_depth, int * max_depth, int * min_value, int * max_value) 查找hash表
3.1 entry_t * trans_entry(trans_t * trans, uint64 key) 根据key在trans表中查找并返回entry
3.2 比对entry相邻的ClusterSize=4个entry, 如果lock与相等，返回entry数值，并更新date。

4. void note_moves(list_t * list, const board_t * board, int height, int trans_killer) 
给list中的每个MOVE打分
4.1 int move_value(int move, const board_t * board, int height, int trans_killer) 
按照TransKiller, Good Capture, Killer, Quiet Move, Bad Capture的顺序打分
4.2 int capture_value(int move, const board_t * board) 
4.2.1 int mvv_lva(int move, const board_t * board) 返回被吃子和走子的PIECE_ORDER差异
4.2.2 bool capture_is_good(int move, const board_t * board)  走子小于被吃的棋子
4.3 int quiet_move_value(int move, const board_t * board) 根据History打分

5. void list_sort(list_t * list)


int search_full_root(list_t * list, board_t * board, int depth, int search_type)
1. int full_root(list_t * list, board_t * board, int alpha, int beta, int depth, int height, int search_type) {

1.1 void search_update_root() 显示当前搜索的根节点着法
1.1.1 void search_update_current() 更新搜索时间、节点数、速度

1.2 int full_new_depth(int depth, int move, board_t * board, bool single_reply, bool in_pv) 
如果唯一应招、好的Re-capture、照将，则depth++;
1.2.1 int see_move(int move, const board_t * board) 
1.2.1.1 void alist_build(alist_t * alist, const board_t * board, int to, int colour) 
		遍历，查找能攻击to格的colour方棋子，返回alist
1.2.1.1.1 void alist_add(alist_t * alist, int square, const board_t * board) 
		将square 加入alist，并按棋子价值排序
1.2.1.2 void alist_remove(alist_t * alist, int pos) 移除alist[pos]
1.2.1.2 int see_rec(alists_t * alists, const board_t * board, int colour, int to, int piece_value)
1.2.1.2.1 int alist_pop(alist_t * alist, const board_t * board) 弹出alist队尾的square
1.2.1.2.2 void alists_hidden(alists_t * alists, const board_t * board, int from, int to) 把被to遮住的slider piece加到alists里
1.2.2 bool move_is_check(int move, board_t * board) move是否照将对方。检查是否直接攻击王或者抽将
1.2.2.1 bool is_pinned(const board_t * board, int square, int colour) square是否在slider与king[colour]之间

1.3 void move_do(board_t * board, int move, undo_t * undo) 走子，并返回undo
存储key，交换行棋方，层数+1，吃子，
1.3.1 void square_clear(board_t * board, int square, int piece, bool update) 
更新棋子列表和数量，计算开局到残局的进度，更新key和子力key
1.3.2 void square_move(board_t * board, int from, int to, int piece, bool update)  走子

1.4 int full_search(board_t * board, int alpha, int beta, int depth, int height, mv_t pv[], int node_type)
1.4.1 int full_quiescence(board_t * board, int alpha, int beta, int depth, int height, mv_t pv[]) 
照将中，depth++
mate-distance pruning
bool trans_retrieve(trans_t * trans, uint64 key, int * move, int * min_depth, int * max_depth, int * min_value, int * max_value) 查找hash表
1.4.2 int value_from_trans(int value, int height) 如果value是杀棋，value加上层数
根据TT查询到的值，进行alpha裁剪和beta裁剪
null-move pruning
1.4.3 void move_do_null(board_t * board, undo_t * undo) 
1.4.4 bool do_ver(const board_t * board) 确认不处在zugzwang局面
1.4.5 int full_no_null(board_t * board, int alpha, int beta, int depth, int height, mv_t pv[], int node_type, int trans_move, int * best_move) {
1.4.6 void sort_init(sort_t * sort, board_t * board, const attack_t * attack, int depth, int height, int trans_killer) 
生成合法着法，返回sort
Single reply extention
1.4.7 int sort_next(sort_t * sort) 阶段性生成下一步着法，测试其合法性后返回
1.4.7.1 int history_prob(int move, const board_t * board) 返回relative history heuristic
1.4.7.1.1 int history_index(int move, const board_t * board) 返回 piece * 64 + tosqure]

history pruning。history 分数低于正常的60%,depth--
futility pruning
1.4.8 bool move_is_dangerous(int move, const board_t * board) 兵即将升变
history-pruning re-search

1.4.9 void good_move(int move, const board_t * board, int depth, int height) 
	move是非吃子的最佳着法。更新killer[2]。history[index]+=depth*depth。history上限16384，超过后与history一起打对折。
1.4.10 void history_bad(int move, const board_t * board) 
	move是非吃子的非最佳着法。HistTot[index]++，上限16384，超过后与history一起打对折。
存储最佳着法
1.4.11 int value_to_trans(int value, int height) 如果胜负已分，value = MATE-height
void trans_store(trans_t * trans, uint64 key, int move, int depth, int min_value, int max_value) 



1.4.1 int full_quiescence(board_t * board, int alpha, int beta, int depth, int height, mv_t pv[]) 
1.4.1.2 void search_check()	看是否到了限定的时间、深度，以结束搜素
1.4.1.2.1 void search_send_stat() 更新搜索统计数据
1.4.1.3 bool board_is_repetition(const board_t * board)
1.4.1.4 bool recog_draw(const board_t * board) 是否官和局面
1.4.1.5 bool board_is_mate(const board_t * board) 被将军且没有规避手段
1.4.1.5.1 void attack_set(attack_t * attack, const board_t * board) 生成所有将军的棋子位置和方向，放到attack列表里
1.4.1.5.2 bool legal_evasion_exist(const board_t * board, const attack_t * attack)  有躲避照将的着法
1.4.1.5.2.1 bool gen_evasions(list_t * list, const board_t * board, const attack_t * attack, bool legal, bool stop) 有无躲避将军的着法，放到list里
